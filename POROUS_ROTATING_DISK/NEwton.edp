/* =======================================

	Computation of Axisymmetric base flow
	
   ======================================= 

	PROGRAM Newton_AxiSwirl.edp
	Computation of Axisymmetric base flow [ux,ur,uphi](x,y)

	THIS FILE IS ADAPTED FROM Newton_Axi.edp

	INPUT PARAMETERS (from keyboard or pipe) :
		Re, ROTATION, POROSITY
	INPUT FILES :
		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
		mesh.msh 			->  mesh in Freefem format
	OUTPUT FILES :
		BaseFlow.txt		-> base flow (FF format)
		BaseFlow.ff2m		-> base flow (FF2M format) 

	ERROR MANAGEMENT : 
		if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.

	INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
	REwriten on october 2 2017 with macros.
...................................................... */

 /* ---------------------
		Import Macros 
    --------------------- */

	include "SF_Geom.edp";
	include "Macros_StabFem.edp";

	if(ncomponentsBF==2)
		{
		cout << "ERROR in Newton_AxiSWIRL :  for this solver the parameter ncomponentsBF should be 3 not 2 !" << endl;
		cout << "Change this in Macro_StabFem.edm" < endl;
		exit(-1);
		} 

/*  -----------------------
		Données maillage
    ----------------------- */
	
	verbosity = 0;
	
	mesh th = readmesh(ffdatadir+"mesh.msh");

/*  ------------------
		Espaces EF 
    ------------------ */

	fespace Xh(th,P2);					//f.e. space for Velocity components
	fespace Mh(th,P1);					//f.e. space for Pressure
	fespace XXMh(th,[P2,P2,P1]);		//f.e. space for Triplet [u,v,p]
	fespace XXXMh(th,[P2,P2,P2,P1]);	//f.e. space for Quadruplet [u,v,w,p]

	XXXMh [ux,ur,uphi,up]; 				// -> unknown for the Navier-Stokes problem
	XXXMh [vx,vr,vphi,vp];				// -> test function for Navier-Stokes
	XXXMh [upx,upr,upphi,upp];			// -> buffer vector to store previous iteration (Newton) 
	XXXMh [dux,dur,duphi,dup];			// -> increment for the Newton iteration
	XXMh [uaxix,uaxir,uaxip];			// -> unknown for the Navier-Stokes problem

/*  ------------------
		Paramètres 
    ------------------ */
	
	real Re;
	real Reans,lecture;
	real Da;
	real Porosity;
	real Omegax;
	real Uinfx = 1;
	
	cout << " Entrer le Nombre de Reynolds :" << endl;
    cin >>  Re;
	
    cout << " Entrer le taux de rotation :" << endl;
    cin >>  Omegax;
	
	cout << " Entrer le Nombre de Darcy du disque :" << endl;
    cin >>  Da;
	
    cout << " Entrer la porosite du disque :" << endl;
    cin >>  Porosity;
		// if(Porosity==0){Porosity=1e-30;};

/*  ---------------------------
		Dimensions Baseflow 
    --------------------------- */

	int NdimUVP = uaxix[].n;
	int NdimUVWP = ux[].n;
	int NdimBaseFlow;
	
	{
	ifstream file(ffdatadir+"BaseFlow_guess.txt");
	file >> NdimBaseFlow ;
	}
		
	if(NdimBaseFlow == NdimUVP) 
		{
        cout << "Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> uaxix[];
        [ux,ur,uphi,up] = [uaxix,uaxir,0,uaxip];
		file >> Reans;
        }
	else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "Ndim = " << NdimUVWP << " : reading UVWP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[]; 
		file >> Reans;
        }
	else 
        {
        cout << " Error : Wrong dimension For BaseFlow_guess.txt file" << endl;
        };

	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl;
	
	real nu = 1./Re;
	real eps = 1e-20; // may not be required

/*  -----------------------
		Macro Operators 
    ----------------------- */

/* Macro for Divergence  */
	macro div(im,u) (dx(u#x)+dy(u#r)+u#r/y+im/y*u#phi)//EOM

/* Macro for Vecocity gradient tensor  */
	macro Grad(im,u) [
			[dx(u#x),	dy(u#x),	im/y*u#x ], 
			[dx(u#r),	dy(u#r),	im/y*u#r-u#phi/y],
			[dx(u#phi),	dy(u#phi),	im/y*u#phi+u#r/y ]
			]//EOM

/* Macro for Rate-of-deformation tensor  */
	macro D(im,u) [	
				[dx(u#x),					.5*(dx(u#r)+dy(u#x)),				.5*(im/y*u#x+dx(u#phi)) ], 
				[.5*(dx(u#r)+dy(u#x)),		dy(u#r),							.5*(im/y*u#r-u#phi/y+dy(u#phi))],
				[.5*(im/y*u#x+dx(u#phi)),	.5*(im/y*u#r-u#phi/y+dy(u#phi)),	im/y*u#phi+u#r/y]
				]//EOM

/* Macro for Mutual convection operator  */
	macro Conv(ima,ua,imb,ub,v) ( 
              (Grad(ima,ua)*[ub#x,ub#r,ub#phi] + Grad(imb,ub)*[ua#x,ua#r,ua#phi])'*[v#x,v#r,v#phi]
              			)//EOM

/* Macro for Integration by parts of (v * Delta (u) ) */
	// macro Diffusion(nu,u1,u2,v1,v2)  (-nu*( dx(u1)*dx(v1)+dy(u1)*dy(v1)+dx(u2)*dx(v2)+dy(u2)*dy(v2)))

/*  -----------------------------------
		Résolution de Navier-Stokes 
    ----------------------------------- */

/* Système linéarisé 1 
	problem NewtonIter([dux,dur,duphi,dup],[vx,vr,vphi,vp]) =
		int2d(th)(
				(	-2*nu*(D(0,du):D(0,v))
					+ vp*div(0,du) 
					+ div(0,v)*dup
					-Conv(0,up,0,du,v)
					-1/Porosity*IsInObject(x,y)*(dux*vx+dur*vr+duphi*vphi)
				)*y)
		+ int2d(th)(
				(	-2*nu*(D(0,up):D(0,v))
					+ vp*div(0,up)
					+ div(0,v)*upp
					-.5*Conv(0,up,0,up,v)
					-1/Porosity*IsInObject(x,y)*(upx*vx+upr*vr+(upphi-Omegax*y)*vphi)
				)*y)
		+ BoundaryconditionsBaseFlow(du,up,v); */

/* Système linéarisé 2 */
	problem NewtonIter([dux,dur,duphi,dup],[vx,vr,vphi,vp]) =
		int2d(th)(
				(	vp*div(0,du)
					- S1(x,y)*Conv(0,up,0,du,v)
					+ dup*div(0,v)
					- 2*nu*S2(x,y)*(D(0,du):D(0,v))
					-IsInObject(x,y)*nu*(1/Da)*(dux*vx+dur*vr+duphi*vphi)
				)*y)
		- int1d(th,91,92,93)(S2(x,y)*((D(0,du)*[N.x,N.y,0])'*[vx,vr,vphi])*y)
		+ int2d(th)(
				(	vp*div(0,up)
					- .5*S1(x,y)*Conv(0,up,0,up,v)
					+ upp*div(0,v)
					- 2*nu*S2(x,y)*(D(0,up):D(0,v))
					- IsInObject(x,y)*nu*(1/Da)*(upx*vx+upr*vr+(upphi-Omegax*y)*vphi)
				)*y)
		- int1d(th,91,92,93)(S2(x,y)*((D(0,u)*[N.x,N.y,0])'*[vx,vr,vphi])*y)
		+ BoundaryconditionsBaseFlow(du,up,v);
    
/* Paramètres de l'algorithme de Newton  */          
	real tolerance = 2e-12;
	real ener = 10;
	int Nitermax = 20;
	int iter = 0;
	
/* Algorithme de Newton  */
	while((ener>tolerance)&(ener<50)&(iter<=Nitermax))
        {
			upx[]=ux[];				// Uold=U
	    
			NewtonIter ;           	// Update of current solution u1=u1-w
			
			ux[] = ux[]+dux[];
        
			IFMACRO(FreeFemPlot,Yes)
				plot(dux,wait=0,value=false,nbiso=50,fill=1,cmm="dux - Re="+int(Re)+" - It="+int(iter)+".");
			ENDIFMACRO
			
			real enerl2=dux[].l2;
			ener = sqrt(int2d(th)(dux^2+dur^2+duphi^2)/th.area);
			cout << " iter = "<< iter+1 << "   Re = " << Re << " res = " << ener << " ; res l2 = " << enerl2 << endl;
			
			iter++;
		} ;

 /* ---------------------------
		Fonction de courant 
    --------------------------- */		
	
	Mh rot;
	Xh upsi,vpsi;
	
	//rot = dx(ub2)-dy(ub1);
		
	solve Courant(upsi,vpsi) =
		int2d(th)(1/y*(dx(upsi)*dx(vpsi)+dy(upsi)*dy(vpsi)))
		//+ on(12,upsi=0)
		+ on(1,upsi=-Uinfx*(y^2/2))
		+ on(3,upsi=-Uinfx*(y^2/2))
		+ on(21,21,23,6,upsi=0);

/*  ----------------------------
		Sortie des résultats 
    ---------------------------- */

/* Si non convergence */
	if((ener>50)||(iter>Nitermax))
		{
		cout << " NEWTON ITERATION FAILED" << endl;
		exec("rm "+ffdatadir+"BaseFlow.txt");
		SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",-1,Da,Porosity,Omegax);
		}
/* Si convergence */
	else
		{
		{ofstream file(ffdatadir+"BaseFlow.txt"); 			// file in .txt format for FreeFem solvers
			file << ux[]; 
			file << endl << endl << Re;
		}; 
		exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt");
		
		SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter,Da,Porosity,Omegax); // file in .ff2ml format for StabFem driver
		
		IFMACRO(FreeFemPlot,Yes)
			plot(upsi,wait=1,value=false,nbiso=50,fill=0,cmm="Lignes courant");
			plot(ux,wait=1,value=true,nbiso=50,fill=1,cmm="final Ux");
			plot(ur,wait=1,value=true,nbiso=50,fill=1,cmm="final Ur");
			plot(uphi,wait=1,value=true,nbiso=50,fill=1,cmm="final Uphi");
		ENDIFMACRO
		  
		Mh uphiphi = uphi;
		cout << "Uphi max : " << uphi[].max;
		
		IFMACRO(FreeFemPlot,Yes)
			plot(up,wait=1,value=true,nbiso=50,fill=1,cmm="final P");
		ENDIFMACRO
		};