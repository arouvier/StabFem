//
//  PROGRAM Newton_2D_Comp.edp
//  computation of 2D base flow [ux,uy](x,y)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Incorporated by David Fabre from a code of Flavio
// Modified by Javier Sierra.


//////////////
//LOADS FROM FLAVIO
//load "MUMPS_FreeFem"
load "MUMPS_FreeFem"
load "scotch";
load "iovtk"
load "./FLAVIOSVERSION/CPP_FUNCTIONS/BinaryIO_64";
include "Params.edp";
///////////////////


/// INCLUDES FROM SF STRUCTURE
		include "SF_Geom.edp";
		include "Macros_StabFem.edp";
		
///

//cout << "mpirank " << mpirank << endl;
//cout << " mpisize " << mpisize << endl;

real ts;
string ssparams = "nprow=1, npcol="+mpisize;
bool fplot=false;
int comp=0;


real Re,Ma;

if(mpirank==0)
{
	cout << " Enter Reynolds Number ?' " << endl;
	cin >> Re;

	cout << " Enter Mach Number ?' " << endl;
	cin >> Ma;

}

broadcast(processor(0),Re); 
broadcast(processor(0),Ma); 
cout << endl << " >>> RE = " << Re << "    ;  Mach = " << Ma << " MPIRANK " << mpirank <<endl;
	    
//////////////////////////////////////////////////////////////////////////////////////////////

real gamma=1.4; 
real Pr=0.7;
real nu=1./Re;    

mesh th;

//include "cyl_mesh.edp";
//mesh th;
if(mpirank==0)
  { 
    th=readmesh(ffdatadir+"mesh.msh");
    int[int] nupart(th.nt);
    nupart=0; 
    if(mpisize>1)
    scotch(nupart, th, mpisize);
    th=change(th,fregion= nupart[nuTriangle]);
   }
broadcast(processor(0),th); 


//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//verbosity=10;
//real Re=1.0;

//////////////////////////////////////////////////////////////////////////////////////////////

real TOLLERANCENewton=1e-9;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=40;  //////////////  Max number of ITERATIONs --> Newton loop

//////////////////////////////////////////////////////////////////////////////////////////////
bool InitSol=false;
string nameoldsol="./Data/B_flow_Re150_M0.2.bin";
string nameoldmesh="TOTOMh.msh";


///////////////////////////////////////////////////////////////////////////////////////////////
fespace XH2(th,P2);
//fespace XH1(th,P1);
//fespace XH0(th,P0);
///////////////////////////////////////////////////////////////////////////////////////////////	
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
//fespace XXxH(th,[P2,P2,P1]);	     ///   vel P2 +press P1
macro def(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF


  
XXxxxH<complex> def(du,dp,dT,drho);
XXxxxH<complex> def(Ub,Pb,Tb,Rhob);
XXxxxH<complex> def(Urif,Prif,Trif,Rhorif)=[1.0,0.0,1.0,1.0,1.0];


XH2 AMPFORCE;
//M=1.0;
AMPFORCE=AmpSponge(Ma);

if(InitSol)
  {
    mesh Tho=readmesh(nameoldmesh);
    fespace Xho(Tho,[P2,P2,P1,P1,P1]);
    Xho def(Uo,Po,To,Rhoo);
    
//    LoadVecPETSc(Uox[],nameoldsol,comp);
    
    //def(Ub,Pb,Tb,Rhob)=def(Uo,Po,To,Rhoo);
    if(mpirank==0)
      cout<<"load initial solution"<<endl;
    
    if(fplot)
      {
	if(mpirank==0)
	  plot(Ubx,value=1);
      }
    /*    
    if(mpirank==0)
    {
    plot(pp,fill=1,value=1,cmm="load field p");
    plot(uyp,fill=1,value=1,cmm="load field uy");
    plot(uxp,fill=1,value=1,cmm="load field ux");
    plot(Tp,fill=1,value=1,cmm="load field T");
    }
    */
  }
 else
   Ubx[]=Urifx[];

func complex Hx(real L, real c, real g)
{
if(x>0)
{
	complex Gx = (1i*g*tanh(x^2/(4*c^2))+1)/(1-x^2/L^2)^2+(4*x^2*(1i*g*tanh(x^2/(4*c^2))+1))/(L^2*(1-x^2/L^2)^3)+(1i*g*x^2*(1/cosh(x^2/(4*c^2)))^2)/(2*c^2*(1-x^2/L^2)^2);
	return 1.0/Gx;
}
else
	return 1.0;
}

func complex Hy(real Rm, real Ra)
{
	if(x > 0 && y > Rm){
		real Gy = 1.0/(1-(y-Rm)^2/(Ra-Rm)^2)^2+(4*(y-Rm)^2)/((Ra-Rm)^2*(1-(y-Rm)^2/(Ra-Rm)^2)^3);
		return 1.0/Gy;
	}
	else if(x > 0 && y < -Rm){

		real Gy = 1.0/(1.0-(y+Rm)^2/(Rm-Ra)^2)^2+(4.0*(y+Rm)^2)/((Rm-Ra)^2*(1-(y+Rm)^2/(Rm-Ra)^2)^3);
		return 1.0/Gy;
	}
	else
		return 1.0;
}
  real xlim = 400;
  real ylim = 360;
  XH2<complex> HX,HY;
  real La = xlim*1.4;
  real Lc = 200.0;
  real gc = 0.5;
  real Lm = 340.0;
  real Lay = ylim*1.7;
  HX=Hx(La,Lc,gc);
  HY=Hy(Lm,Lay);
  macro Dx(a) (dx(a)*HX) //
  macro Dy(a) (dy(a)*HY) //

  macro div(u) ((Dx(u#x)+Dy(u#y)))   //EOM
  macro ugradf(u,f) ((u#x*Dx(f)+u#y*Dy(f)))    //
//macro gradfgradf(f,f1) ((Dx(f)*Dx(f1)+Dy(f)*Dy(f1)))  //
//macro strain(u1,u2,v1,v2) ((Dx(u1)*Dx(v1)+(1./2)*(Dx(u2)+Dy(u1))*(Dx(v2)+Dy(v1))+Dy(u2)*Dy(v2)))  //
  macro termnonlinear(u,v,w) ((w#x*(u#x*Dx(v#x)+u#y*Dy(v#x))+w#y*(u#x*Dx(v#y)+u#y*Dy(v#y)))) //
  macro Grad(u) [[Dx(u#x),Dx(u#y)],[Dy(u#x),Dy(u#y)]]//EOM
  macro Strain(u)[[Dx(u#x),0.5*(Dx(u#y)+Dy(u#x))],[0.5*(Dx(u#y)+Dy(u#x)),Dy(u#y)]]//EOM
  macro gradgrad(u,v)(Dx(u)*Dx(v)+Dy(u)*Dy(v))//EOM
  
  varf dirichlet(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=on(bcinlet,dux=1.0-Ubx,duy=0.0-Uby,dT=1.-Tb,drho=1.-Rhob)
  +on(bcoutflow,dux=1.0-Ubx,duy=0.0-Uby,dT=1.-Tb,drho=1.-Rhob)
  +on(bcwall,dux=0.0-Ubx,duy=0.0-Uby);

varf jacobian(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=int2d(th,mpirank)( (1.0/(HX*HY))*((rhos*(drho*div(Ub)+Rhob*div(du)+ugradf(Ub,drho)+ugradf(du,Rhob)) 
								       //mass equation
								       -dp/(gamma*Ma^2)*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))+Rhob*termnonlinear(du,Ub,us)+drho*termnonlinear(Ub,Ub,us)+Rhob*termnonlinear(Ub,du,us)
								       //momentum
								  +Ts*(drho*ugradf(Ub,Tb)+Rhob*ugradf(Ub,dT)+Rhob*ugradf(du,Tb)+(gamma-1)*(div(Ub)*dp + Pb*div(du))-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))-2.0/3.0*(2.0*div(Ub)*div(du))))+gamma/(Pr*Re)*gradgrad(dT,Ts)
								       // energy
								       +ps*(dp-(drho*Tb+Rhob*dT))
								  )))
  //+int2d(th,mpirank)(AMPFORCE*(usy*duy+usx*dux+Ts*dT+rhos*drho))
  +BoundaryconditionsBaseFlow(du,dp,dT,drho);


varf vNs(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=-int2d(th,mpirank)( (1.0/(HX*HY))*(rhos*(Rhob*div(Ub)+ugradf(Ub,Rhob))
							   //mass equation
							   -Pb/(gamma*Ma^2)*div(us)+2.0/Re*(Strain(Ub):Grad(us))-2.0/(3.0*Re)*(div(Ub)*div(us))+Rhob*termnonlinear(Ub,Ub,us)
							   //momentum
								   +Ts*(Rhob*ugradf(Ub,Tb)+(gamma-1)*Pb*div(Ub)-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(Ub):Strain(Ub)))-2.0/3.0*(div(Ub)*div(Ub))))+gamma/(Pr*Re)*gradgrad(Tb,Ts)
							   // energy
							   +ps*(Pb-(Rhob*Tb))
							   ))
  //-int2d(th,mpirank)(AMPFORCE*(usy*(Uby-Urify)+usx*(Ubx-Urifx)+Ts*(Tb-Trif)+rhos*(Rhob-Rhorif)))
  +BoundaryconditionsBaseFlow(du,dp,dT,drho);

real res,ener=1.;
if(mpirank==0)
  {
    cout << " ................................................... "<< endl;	
    cout << " ................................................... "<< endl;	
  }
int contout=0;

  
    ///////////////////////////////////////////////////////////////////////
    
    
    

	AMPFORCE=AmpSponge(Ma);
	res=1.0;
	ener=1.0;
	

	 
	  int i=0;
	  while((ener>TOLLERANCENewton)&(i<=NITERATIONNEWTLOOP))
	    {
	      ts=clock();
	      
	      matrix<complex> NewtLoc=jacobian(XXxxxH,XXxxxH);
	      matrix<complex> Newt;
	      mpiAllReduce(NewtLoc,Newt,mpiCommWorld,mpiSUM);
	      if(mpirank==0)
		cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl;  
	      complex[int] rhsl= vNs(0,XXxxxH);
	      complex[int] rhs(Newt.n);
	      mpiAllReduce(rhsl,rhs,mpiCommWorld,mpiSUM);
	      set(Newt,solver=sparsesolver,sparams=ssparams);
	      dux[] =  (Newt^-1*rhs);
	      ener=sqrt(int2d(th)(abs(duy)^2+abs(dux)^2)); 
	      if(mpirank==0)
		{
		  cout << "iter "<<i<<" | sqrt(int2d(th)(dux^2+duy^2)) = " << ener << endl;
		}
	      Ubx[]+=dux[];
	      i++;	    
	      
	     }// end of NEWTON LOOP
	     
	     /// NEXT IS PLOT AND POSTPROCESS
	  
	  if(mpirank==0)
	    {
	      //cout << "p,T,rho,u,v at (5,0): " << pp(5,0) << " " << Tp(5,0) << " " << rhop(5,0) << " " << uxp(5,0) << " " << uyp(5,0) << endl;
	      cout << " -------------------------------------------------------- "<< endl;	
	      plot(Pb,fill=1,value=1,cmm="press");
	      plot(Uby,fill=1,value=1,cmm="vel: y-component");
	      plot(Ubx,fill=1,value=1,cmm="vel: x-component");
	      plot(Tb,fill=1,value=1,cmm="Temp");
	      plot(Rhob,fill=1,value=1,cmm="density");
	      cout << " Newton iteration ok!"<< endl;
	    };
	  
	  
	  
	  ////// OUTPUT FOR STABFEM  
	    
	    // sortie des r?sultats 

//		if((ener>50)||(iter>Nitermax))
//		{
//			cout << " NEWTON ITERATION FAILED" << endl;
//			exec("rm "+ffdatadir+"BaseFlow.txt");
//			SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",-1);
//		}
//		else
		
		{
		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << Ubx[]; 
		  file << endl << endl << Re;
		  }; 
          exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 

// temporary fix
XXxxxH [ux,uy,up,utemp,uro] = [real(Ubx),real(Uby),real(Pb),real(Tb),real(Rhob)];
         

          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",i); // file in .ff2ml format for StabFem driver
          int[int] forder=[1,1,1,1];
		  savevtk(ffdatadir+"/BflowCM_Re"+Re+"_M"+Ma+".vtk",th,up,[ux,uy,0],utemp,uro,order=forder,dataname="Pb vel temp rho");
        
		};
          

	    
	    
	  




