//
//  PROGRAM DNSComp.edp
//  computation of 2D optimal perturbation for maximum transient growth at time tEnd.
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma, dt, tEnd
//	INPUT FILES :
//		BaseFlow.txt	-> base flow (generated by Newton_2D_Comp.edp)
//		Eigenmode.txt	-> eigenmode (generated by Stab2dComp.edp) It is the initial condition, we could set any random field satisfying BC...
// 		mesh.msh 	->  mesh in Freefem format
//  OUTPUT FILES :
//		TGrowth_Re.vtk       -> Initial optimal disturbance in format VTK
// 		TResponse_Re.vtk     -> Response at time tEnd in format VTK
//      	TGrowth.ff2m         -> StabFEM file for transient growth
//		GainConvergence.txt  -> History of energy gain
//
//
//



//////////////
//LOADS FROM FLAVIO
load "iovtk"
//load "MUMPS_FreeFem"
load "MUMPS_seq";
load "scotch";
load "./FLAVIOSVERSION/CPP_FUNCTIONS/BinaryIO_64";
include "Params.edp";
///////////////////


/// INCLUDES FROM SF STRUCTURE
		include "SF_Geom.edp";
		include "Macros_StabFem.edp";		
///



real ts;
string ssparams = "nprow=1, npcol="+mpisize;
bool fplot=false;
int comp=0;


real Re,M;
// Time parameters
real dt,tCurrent,tEnd;

if(mpirank==0)
{
	cout << " Enter Reynolds Number ?' " << endl;
	cin >> Re;

	cout << " Enter Mach Number ?' " << endl;
	cin >> M;

	cout << " Enter tEnd ?' " << endl;
	cin >> tEnd;

	cout << " Enter dt ?' " << endl;
	cin >> dt;

	cout << endl << " >>> RE = " << Re << "    ;  Mach = " << M << endl;
}

	    
	    cout << endl << " >>> RE = " << Re << "    ;  Mach = " << M << "; tEnd = " << tEnd << "; dt = " << dt << endl;




//////////////////////////////////////////////////////////////////////////////////////////////

real gamma=1.4; 
real Pr=0.7;
real nu=1./Re;    
real Mbflow=M;
real Ma = M;
bool AvgComp = true;
real[int] Gain(10);
Gain(0:10:1) = 0.0;
//dt = 0.4;
//tEnd = 1.0;
tCurrent = 0.0;
int niter = 10000;
int[int] forder=[1,1,1,1,1,1,1,1];



mesh th;



//include "cyl_mesh.edp";
//mesh th;
if(mpirank==0)
  { 
    th=readmesh(ffdatadir+"mesh.msh");
    int[int] nupart(th.nt);
    nupart=0; 
    if(mpisize>1)
    scotch(nupart, th, mpisize);
    th=change(th,fregion= nupart[nuTriangle]);
   }
broadcast(processor(0),th); 


//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//verbosity=10;
//real Re=1.0;

//////////////////////////////////////////////////////////////////////////////////////////////

real TOLLERANCENewton=1e-9;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=20;  //////////////  Max number of ITERATIONs --> Newton loop

//////////////////////////////////////////////////////////////////////////////////////////////
bool InitSol=false;
string nameoldsol="./Data/B_flow_Re150_M0.2.bin";
string nameoldmesh="TOTOMh.msh";


///////////////////////////////////////////////////////////////////////////////////////////////
fespace XH2(th,P2);
fespace Xh(th,P2);             ////// f.e. space for vel.
fespace XH1(th,P1);
//fespace XH0(th,P0);
///////////////////////////////////////////////////////////////////////////////////////////////	
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
fespace XXxxH(th,[P2,P2,P1,P1]); ///   vel 2x P2 + temp P1 + dens P1

//fespace XXxH(th,[P2,P2,P1]);	     ///   vel P2 +press P1
macro def(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF
macro def4(u,T,rho)[u#x,u#y,T,rho]//EOF


  
XXxxH def4(u,uT,urho);
XXxxxH def(uMode,uModep,uModeT,uModerho);

XXxxxH<complex> def(uC,uCp,uCT,uCrho);
XXxxH def4(u1,T1,rho1);
XXxxH def4(u2,T2,rho2);
XXxxH def4(u3,T3,rho3);
XXxxH def4(u4,T4,rho4);
XXxxH def4(urhs,Trhs,rhorhs);
XXxxxH def(Ub,Pb,Tb,Rhob);
XXxxxH def(Urif,Prif,Trif,Rhorif);//


// Initial guess
{
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> Urifx[];
//		file >> Reans;
};


XH2 AMPFORCE;
//M=1.0;
AMPFORCE=AmpSponge(M);

if(InitSol)
  {
    mesh Tho=readmesh(nameoldmesh);
    fespace Xho(Tho,[P2,P2,P1,P1,P1]);
    Xho def(Uo,Po,To,Rhoo);
    
//    LoadVecPETSc(Uox[],nameoldsol,comp);
    
    def(Ub,Pb,Tb,Rhob)=def(Uo,Po,To,Rhoo);
    if(mpirank==0)
      cout<<"load initial solution"<<endl;
    
    if(fplot)
      {
	if(mpirank==0)
	  plot(Ubx,value=1);
      }
    /*    
    if(mpirank==0)
    {
    plot(pp,fill=1,value=1,cmm="load field p");
    plot(uyp,fill=1,value=1,cmm="load field uy");
    plot(uxp,fill=1,value=1,cmm="load field ux");
    plot(Tp,fill=1,value=1,cmm="load field T");
    }
    */
  }
 else
   Ubx[]=Urifx[];
  macro div(u) ((dx(u#x)+dy(u#y)))   //EOM
  macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f)))    //
  macro ugraduTx(u,v) ((u#x*dx(v#x)+u#y*dx(v#y)))    //
  macro ugraduTy(u,v) ((u#x*dy(v#x)+u#y*dy(v#y)))    //
  macro innerproduct(u,v) ((u#x*v#x + u#y*v#y)) // EOM
  macro prodgradfStrain(u,f,v) (v#x*(dx(f)*(2.0*dx(u#x)) +dy(f)*(dy(u#x)+dx(u#y)) ) + v#y*( dx(f)*(dy(u#x)+dx(u#y)) + dy(f)*(2.0*dy(u#y)) ) ) //EOM
//macro gradfgradf(f,f1) ((dx(f)*dx(f1)+dy(f)*dy(f1)))  //
//macro strain(u1,u2,v1,v2) ((dx(u1)*dx(v1)+(1./2)*(dx(u2)+dy(u1))*(dx(v2)+dy(v1))+dy(u2)*dy(v2)))  //
  macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) //
  macro Grad(u) [[dx(u#x),dx(u#y)],[dy(u#x),dy(u#y)]]//EOM
  macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x))],[0.5*(dx(u#y)+dy(u#x)),dy(u#y)]]//EOM
  macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM
  macro EnergyNorm(u,U) sqrt(int2d(th)(  Rhob*(abs(u#x)^2+abs(u#y)^2+abs(u#T)^2) + abs(u#rho)^2 ) )//
  
  varf dirichlet(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=on(bcinlet,dux=0.0,duy=0.0-Uby,dT=0.0)
  +on(bcoutflow,duy=0.0)
  +on(bcwall,dux=0.0,duy=0.0);


varf jacobian(def4(du,dT,drho),def4(us,Ts,rhos))=int2d(th,mpirank)(rhos*(drho*div(Ub)+Rhob*div(du)+ugradf(Ub,drho)+ugradf(du,Rhob)) 
								       //mass equation
								       -((drho*Tb+Rhob*dT)/gamma*Ma^2)*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))+Rhob*termnonlinear(du,Ub,us)+drho*termnonlinear(Ub,Ub,us)+Rhob*termnonlinear(Ub,du,us)
								       //momentum
								       +Ts*(drho*ugradf(Ub,Tb)+Rhob*ugradf(Ub,dT)+Rhob*ugradf(du,Tb)+(gamma-1)*(drho*Tb*div(Ub)+Rhob*dT*div(Ub)+Rhob*Tb*div(du))-gamma*(gamma-1.0)*M^2/Re*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))-2.0/3.0*(2.0*div(Ub)*div(du))))+gamma/(Pr*Re)*gradgrad(dT,Ts)
								       // energy
								       )
  +int2d(th,mpirank)(AMPFORCE*(usy*duy+usx*dux+Ts*dT+rhos*drho))
  +dirichlet;


varf LNSEadjointDiscrete(def4(du,dT,drho),def4(us,Ts,rhos))=int2d(th,mpirank)(rhos*(-ugradf(Ub,drho) + termnonlinear(Ub,Ub,du) + dT*ugradf(Ub,Tb) - Tb*(1.0/(gamma*Ma^2)*div(du) - (gamma-1.0)*dT*div(Ub))) 
								       //mass equation
								       -Rhob*ugradf(us,drho) + Rhob*ugradf(us,Tb)*dT - Rhob*termnonlinear(Ub,du,us) 
								       + Rhob*termnonlinear(us,Ub,du) +2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))
									- (gamma-1.0)*Pb*ugradf(us,dT) - (gamma-1.0)*dT*ugradf(us,Pb) - 2*gamma*(gamma-1.0)*(Ma^2/Re)*dT*((2.0*Strain(Ub):Grad(us))-2.0/(3.0*Re)*(div(Ub)*div(us))) + 2*gamma*(gamma-1.0)*(Ma^2/Re)*(ugradf(us,dT)*div(Ub) + prodgradfStrain(Ub,dT,us) )
								       //momentum
								  +Ts*(-Rhob*ugradf(Ub,dT) - Rhob*(1.0/(gamma*Ma^2)*div(du) - (gamma-1.0)*dT*div(Ub))) + gamma/(Pr*Re)*gradgrad(dT,Ts)
								       // energy
								  )
  -int2d(th,mpirank)(AMPFORCE*(usy*duy+usx*dux+Ts*dT+rhos*drho))
  +dirichlet;



varf vNs(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=-int2d(th,mpirank)(rhos*(urho*div(u)*urho+ugradf(u,urho))
							   //mass equation
							   +Rhob*termnonlinear(u,u,us) + urho*termnonlinear(Ub,u,us) + urho*termnonlinear(u,Ub,us)
							   //momentum
								   +Ts*(urho*ugradf(u,uT) + Rhob*ugradf(u,uT) + urho*ugradf(Ub,uT) + urho*ugradf(u,Tb) +(gamma-1.)*urho*uT*div(u) + (gamma-1.)*Rhob*uT*div(u) + (gamma-1.)*urho*Tb*div(u) + (gamma-1.)*urho*uT*div(Ub) -gamma*(gamma-1.0)*M^2/Re*(2.0*((Strain(u):Strain(u)))-2.0/3.0*(div(u)*div(u))))
							   // energy
							   +ps*(-(Rhob*Tb))
							   )
  +dirichlet;

varf bmat(def4(du,dT,drho),def4(us,Ts,rhos))=int2d(th,mpirank)(rhos*(drho)+(Rhob)*(duy)*usy+(Rhob)*(dux)*usx+Ts*(Rhob)*(dT));
varf bInvmat(def4(du,dT,drho),def4(us,Ts,rhos))=int2d(th,mpirank)(rhos*(drho)+(1.0/Rhob)*(duy)*usy+(1.0/Rhob)*(dux)*usx+Ts*(1.0/Rhob)*(dT));

real res,ener=1.;
if(mpirank==0)
  {
    cout << " ................................................... "<< endl;	
    cout << " ................................................... "<< endl;	
  }
int contout=0;

  
{
ifstream cbin(ffdatadir+"BaseFlow.txt");
cbin >> Ubx[];
}
    ///////////////////////////////////////////////////////////////////////
    
    
    

	AMPFORCE=AmpSponge(M);
	res=1.0;
	ener=1.0;
	
	 int testCB = exec("ls WORK/Eigenmode.txt");
    	if (testCB!=0)
		{
		cout << "no file Eigenmode_guess.txt : strarting from arbitrary initial condition" << endl;
		[ux,uy,uT,urho] = [1.0,0.0,1.0,1.0];
		} 
		else
		{
		cout << "Starting DNS from mode of Eigenmode.txt" << endl;
		ifstream cbin(ffdatadir+"Eigenmode.txt");
		(cbin) >> uCx[];

		real NormE = EnergyNorm(uC,Ub);
		for (int j=0;j<uCx[].n ; j++) uModex[][j] = (sqrt(2)/NormE)*real(uCx[][j]) ;
		for (int j=0;j<uCy[].n ; j++) uModey[][j] = (sqrt(2)/NormE)*real(uCy[][j]) ;
		for (int j=0;j<uCp[].n ; j++) uModep[][j] = (sqrt(2)/NormE)*real(uCp[][j]) ;
		for (int j=0;j<uCT[].n ; j++) uModeT[][j] = (sqrt(2)/NormE)*real(uCT[][j]) ;
		for (int j=0;j<uCrho[].n ; j++) uModerho[][j] = (sqrt(2)/NormE)*real(uCrho[][j]) ;
		def4(u,uT,urho) = def4(uMode,uModeT,uModerho);
		NormE = EnergyNorm(u,Ub);
		cout << "Norm of the initialization " << NormE << endl;
		};
	  int i=0;

	  
		ts=clock();
		matrix Bloc= bmat(XXxxH,XXxxH,solver=CG,eps=1e-20);  //////// WARNING: THE SOLVER !!!!!!!!!!!!!!!
		matrix B;
		mpiAllReduce(Bloc,B,mpiCommWorld,mpiSUM);
		if(mpirank==0)
		  {
		    cout << "### B is ok !" << endl;
		    cout <<" ### B assembled in "<<clock()-ts<<" s"<<endl;
		  }
		ts=clock();
		matrix BInvloc= bInvmat(XXxxH,XXxxH);  //////// WARNING: THE SOLVER !!!!!!!!!!!!!!!
		matrix BInv;
		mpiAllReduce(BInvloc,BInv,mpiCommWorld,mpiSUM);
		if(mpirank==0)
		  {
		    cout << "### BInv is ok !" << endl;
		    cout <<" ### BInv assembled in "<<clock()-ts<<" s"<<endl;
		  }
	      ts=clock();
	      matrix JacLocal=jacobian(XXxxH,XXxxH);
	      matrix Jact;
	      matrix LHS;
	      mpiAllReduce(JacLocal,Jact,mpiCommWorld,mpiSUM);
	      if(mpirank==0)
		      cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl; 

		   ts=clock();
		  matrix JacLocalAdj=LNSEadjointDiscrete(XXxxH,XXxxH);
		  matrix JacAdjt;
		  matrix LHSAdj;
		  mpiAllReduce(JacLocalAdj,JacAdjt,mpiCommWorld,mpiSUM);
		  if(mpirank==0)
		      cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl;  


for(int iter=0; iter < 10; iter++)
{	  
	
	if(iter > 0)
	{
		if((Gain[iter] - Gain[iter-1])/Gain[iter] < 1e-2)
		{
			cout << "The relative difference is " << (Gain[iter] - Gain[iter-1])/Gain[iter] << " and the process have converged" << endl;;
			break;
		}
	}
	  // RENORMALIZATION
	  real NormE = EnergyNorm(u,Ub);
	  ux[] = ux[]/NormE;
	  while((i<=niter && tCurrent < tEnd))
	    {
		      if(i == 0)
		      {
			u1x[] = ux[]; // The previous state
			urhsx[] = B*u1x[]; // The previous state
		        LHS = B + dt*Jact; // I compute it in one core, it may speed up if we compute it locally
		        set(LHS,solver=sparsesolver,sparams=ssparams);
		        ux[] =  (LHS^-1*urhsx[]);
		      }

		      ////// BUILD B-MATRIX
		      u2x[] = -(1./3.)*u1x[]; // The before previous state
		      u1x[] = (4./3.)*ux[]; // The previous state
	  	      urhsx[] = B*u1x[];
		      urhsx[] += B*u2x[];
		      u2x[] = u1x[]; // To get back the previous state
		      u1x[] = ux[]; // The previous state
		      LHS = B + dt*Jact; // I compute it in one core, it may speed up if we compute it locally
		      set(LHS,solver=sparsesolver,sparams=ssparams);
		      ux[] =  (LHS^-1*urhsx[]);
		      tCurrent+=dt;
		      i++;	   
		      ener=EnergyNorm(u,Ub);
		      if(mpirank==0)
			{
			  cout << "Power method iteration " << iter << endl;
			  cout << "iter "<< i <<" | B-Norm = " << ener << endl;
			  cout << "tCurrent "<< tCurrent <<" | tEnd " << tEnd << endl;
			}		
		      

	       
		}// End of linear DNS
	Gain[iter] = ener;
	tCurrent = 0.0;
	i=0;
	// ux[] =  BInv*ux[]; // Multiplication to be in accordance with the norm if we consider the adjoint constraint with B scalar product (I do not think so)
	savevtk("WORK/TResponse_"+iter+".vtk",th,[ux,uy,0],uT,urho,order=forder,dataname="u T rho");
	while((i<=niter && tCurrent < tEnd))
	    {
		      ////// BUILD B-MATRIX
		      
		      if(i == 0)
		      {
			u1x[] = ux[]; // The previous state
			urhsx[] = B*u1x[]; // The previous state
	  	        urhsx[] *= (1.0/dt);
		        LHSAdj = (1.0/dt)*B + JacAdjt; // I compute it in one core, it may speed up if we compute it locally
		        set(LHSAdj,solver=sparsesolver,sparams=ssparams);
		        ux[] =  (LHSAdj^-1*urhsx[]);
		      }

			////// BUILD B-MATRIX
		      u2x[] = -(1./3.)*u1x[]; // The before previous state
		      u1x[] = (4./3.)*ux[]; // The previous state
	  	      urhsx[] = B*u1x[];
		      urhsx[] += B*u2x[];
		      u2x[] = u1x[]; // To get back the previous state
		      u1x[] = ux[]; // The previous state
		      LHSAdj = B + dt*JacAdjt; // I compute it in one core, it may speed up if we compute it locally
		      set(LHSAdj,solver=sparsesolver,sparams=ssparams);
		      ux[] =  (LHSAdj^-1*urhsx[]);
		      i++;
		      tCurrent+=dt;
		      ener=EnergyNorm(u,Ub);
		      if(mpirank==0)
			{
			  cout << "Power method iteration " << iter << endl;
			  cout << "iter "<<i<<" | B-Norm = " << ener << endl;
			  cout << "tCurrent "<< tCurrent <<" | tEnd " << tEnd << endl;
			}
	 
		}// End of linear DNS
	tCurrent = 0.0;
	i = 0;
	savevtk("WORK/TGrowth_"+iter+".vtk",th,[ux,uy,0],uT,urho,order=forder,dataname="u T rho");
} // END POWER ITERATION


{
XXxxxH [ux,uy,up,utemp,uro] = [ux,uy,0.0,uT,urho];
savevtk("WORK/TGrowth_Re_"+Re+"_Ma_"+Ma+"_tEnd_"+tEnd+".vtk",th,[ux,uy,0],uT,urho,order=forder,dataname="u T rho");
ofstream file(ffdatadir+"TGrowth.txt"); // file in .txt format for FreeFem solvers
file << ux[]; 
file << endl << endl << Re;
exec("cp "+ffdatadir+"TGrowth_Re_"+Re+"_Ma_"+Ma+"_tEnd_"+tEnd+".txt "+ffdatadir+"TGrowth_guess.txt"); 
SFWriteBaseFlow(ffdatadir+"TGrowth.ff2m",u,"TGrowth",10); // file in .ff2ml format for StabFem driver
file << endl;
ofstream fileGain(ffdatadir+"GainConvergence.txt"); // file in .txt format for FreeFem solvers
for(int iter=0; iter < 10; iter++) fileGain << Gain[iter] << endl; 
}
	  
 
